<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Together We Are One</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Supabase -->
  <script src="https://unpkg.com/@supabase/supabase-js@2"></script>

  <!-- PNG Export helper -->
  <script src="https://unpkg.com/leaflet-image@0.4.0/leaflet-image.js"></script>

  <style>
    :root{
      --bg0:#0b0d12;
      --bg1:#121526;
      --card: rgba(255,255,255,0.06);
      --card2: rgba(255,255,255,0.08);
      --stroke: rgba(255,255,255,0.10);

      --ghost: rgba(255,255,255,0.22);
      --text: rgba(255,255,255,0.92);
      --warm: rgba(255,220,170,0.95);

      /* Anzeige-Look (fix, ohne User-Regler) */
      --map-brightness: 0.64;
      --map-contrast: 1.25;
      --map-saturate: 0.0;   /* Graustufe */
      --shade-opacity: 0.90;
      --ocean-tint: rgba(0,0,0,0.38);
    }

    html,body { height:100%; }
    body{
      margin:0;
      color: var(--text);
      background:
        radial-gradient(1200px 700px at 50% 12%, rgba(40,60,110,0.35) 0%, rgba(0,0,0,0) 55%),
        radial-gradient(900px 520px at 20% 8%, rgba(130,90,40,0.18) 0%, rgba(0,0,0,0) 55%),
        linear-gradient(180deg, var(--bg1), var(--bg0));
      font-family: ui-sans-serif, system-ui, -apple-system, "SF Pro Display", "Inter", "Segoe UI", Arial, sans-serif;
      overflow-x:hidden;
    }

    .wrap{
      min-height:100%;
      display:grid;
      grid-template-rows:auto auto 1fr auto;
      gap:14px;
      padding:18px 14px;
      box-sizing:border-box;
      max-width:1100px;
      margin:0 auto;
    }

    /* --- Prompter --- */
    .teleprompter{
      padding:18px 18px 14px 18px;
      border-radius:20px;
      background: linear-gradient(180deg, var(--card2), var(--card));
      border: 1px solid var(--stroke);
      box-shadow: 0 16px 60px rgba(0,0,0,0.35);
      backdrop-filter: blur(10px);
    }
    .tp-text{
      display: block;
      max-width: 28em;
      margin: 0 auto;

      text-align: center;
      font-size: clamp(18px, 2.5vw, 30px);
      line-height: 1.45;
      padding: 8px 10px 10px 10px;
      overflow-wrap: normal;
      word-break: keep-all;
    }
    .tp-word{
      color: var(--ghost);
      transition: color 160ms ease, filter 160ms ease;
      white-space: normal;
      overflow-wrap: normal;
      word-break: keep-all;
    }
    .tp-space{ white-space: normal;}
    .tp-word.done{
      color: var(--warm);
      filter: drop-shadow(0 0 12px rgba(255,210,140,0.18));
    }
    .tp-word.active{
      color: rgba(255,245,235,0.98);
      filter: drop-shadow(0 0 18px rgba(255,210,140,0.26));
    }

    .tp-meta{
      display:flex; align-items:center; justify-content:center;
      gap:10px; margin-top:8px; user-select:none;
    }
    .tp-btn{
      width:42px; height:42px; border-radius:14px;
      border:1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.85);
      cursor:pointer;
      transition: background 140ms ease, transform 140ms ease;
      font-size:18px; font-weight:700;
    }
    .tp-btn:hover{ background: rgba(255,255,255,0.10); transform: translateY(-1px); }

    .tp-progress{
      width: min(520px, 62vw);
      height:8px;
      border-radius:8px;
      overflow:hidden;
      background: rgba(255,255,255,0.10);
      border:1px solid rgba(255,255,255,0.08);
    }
    .tp-progress-bar{
      height:100%;
      width:0%;
      background: linear-gradient(90deg, rgba(255,220,170,0.65), rgba(255,255,255,0.55));
      transition: width 220ms ease;
    }

    /* --- Map --- */
    .mapWrap{
      position:relative;
      border-radius:20px;
      overflow:hidden;
      border:1px solid rgba(255,255,255,0.10);
      box-shadow: 0 16px 60px rgba(0,0,0,0.35);
      background:#0a0b10;
    }
    #map{ width:100%; height: min(62vh, 520px); }
    #map, #map *{
  cursor: crosshair !important;   /* oder: default, cellhair, move */
}


    /* On-screen: Graustufe + dunkler */
    .leaflet-tile{
      filter:
        grayscale(1)
        brightness(var(--map-brightness))
        contrast(var(--map-contrast))
        saturate(var(--map-saturate));
    }

    .mapTint{
      pointer-events:none;
      position:absolute; inset:0;
      background: var(--ocean-tint);
      mix-blend-mode: multiply;
      opacity:1;
    }
    .mapShade{
      pointer-events:none;
      position:absolute; inset:0;
      opacity: var(--shade-opacity);
      background:
        radial-gradient(900px 420px at 50% 10%, rgba(0,0,0,0.18), rgba(0,0,0,0.86) 65%),
        radial-gradient(700px 520px at 10% 80%, rgba(0,0,0,0.12), rgba(0,0,0,0.78) 72%),
        linear-gradient(180deg, rgba(0,0,0,0.14), rgba(0,0,0,0.70));
      mix-blend-mode: multiply;
    }

    .hud{
      position:absolute;
      left:12px; top:12px;
      display:flex; gap:10px;
      z-index:500;
      flex-wrap:wrap;
      align-items:center;
    }
    .hud button{
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.24);
      color: rgba(255,255,255,0.92);
      cursor:pointer;
      backdrop-filter: blur(10px);
      transition: background 140ms ease, transform 140ms ease;
      font-weight:650;
      letter-spacing:0.2px;
    }
    .hud button:hover{ background: rgba(0,0,0,0.32); transform: translateY(-1px); }

    .hint{ text-align:center; margin:4px 0 0 0; color: rgba(255,255,255,0.60); font-size:14px; }
    .status{ text-align:center; color: rgba(255,255,255,0.70); font-size:13px; margin-top:6px; }

    @media (max-width:600px){
      .wrap{ padding:12px 10px; }
      .teleprompter{ padding:14px 12px 12px 12px; border-radius:18px; }
      .tp-btn{ width:40px; height:40px; border-radius:14px; }
      #map{ height:52vh; }
      
    }
    #langBadge{
  position: fixed;
  left: 10px;
  top: 10px;
  z-index: 9999;
  padding: 6px 8px;
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,0.12);
  background: rgba(0,0,0,0.25);
  color: rgba(255,255,255,0.85);
  font: 600 12px/1 ui-sans-serif, system-ui, -apple-system, "Inter", "Segoe UI", Arial, sans-serif;
  letter-spacing: 0.08em;
  backdrop-filter: blur(8px);
}
  </style>
</head>

<body>
  <div id="langBadge" aria-label="Language"></div>
  <div class="wrap">

    <div class="teleprompter" aria-label="Text">
      <p class="tp-text" id="tp-text"></p>
      <div class="tp-meta">
        <button class="tp-btn" id="tp-prev" title="Zurück" aria-label="Zurück">←</button>
        <div class="tp-progress"><div class="tp-progress-bar" id="tp-bar"></div></div>
        <button class="tp-btn" id="tp-next" title="Weiter" aria-label="Weiter">→</button>
      </div>
    </div>

    <div class="mapWrap" id="mapWrap">
      <div class="hud">
        <button id="btnWorld" title="Ein Erdball (ohne Wrap / ohne doppelte Kontinente)">Weltansicht</button>
        <button id="btnCard" title="Screenshot vom Erdball (Graustufe, dunkel, mit Lichtern)">Karte generieren</button>
      </div>

      <div id="map"></div>
      <div class="mapTint"></div>
      <div class="mapShade"></div>
    </div>

    <p class="hint" id="hint"></p>
    <p class="status" id="status"></p>
  </div>

<script>
/* -------------------------
   1) PROMPTER (unverändert, mit Zeilenumbruch)
-------------------------- */
// --- Language selection (URL override ?lang=xx, otherwise browser) ---
function getLangFromUrl() {
  const p = new URLSearchParams(location.search);
  const v = (p.get("lang") || "").trim();
  return v ? v.toLowerCase() : null;
}

function normalizeLang(tag) {
  if (!tag) return "en";
  const t = tag.toLowerCase();

  // Chinese script handling
  if (t.startsWith("zh")) return "zh";

  // Map "in" to "id" (old code), "iw" to "he" etc.
  if (t.startsWith("in")) return "id";
  if (t.startsWith("iw")) return "he";

  // Use primary subtag: "de-de" -> "de"
  return t.split("-")[0];
}

const SUPPORTED = ["en","es","hi","zh","ar","ru","de"]; // de optional for you

function pickLanguage() {
  // 1) URL override
  const urlLang = normalizeLang(getLangFromUrl());
  if (urlLang && SUPPORTED.includes(urlLang)) return urlLang;

  // 2) Browser preferences
  const prefs = (navigator.languages && navigator.languages.length)
    ? navigator.languages
    : [navigator.language || "en"];

  for (const tag of prefs) {
    const base = normalizeLang(tag);
    if (SUPPORTED.includes(base)) return base;
  }

  // 3) fallback
  return "en";
}

const LANG = pickLanguage();
const badge = document.getElementById("langBadge");
if (badge) badge.textContent = LANG.toUpperCase();

// --- Teleprompter texts per language ---
const TP = {
  de: [
    "Dass wir hier sind, auf diesem blauen Planeten tief im Weltall, ist ein unglaublicher Zufall.",
    "Dieses Glück teilen wir alle.",
    "Wir sind alle etwas Besonderes – und zugleich eins.",
    "Als Teil dieser Gemeinschaft haben wir die Kraft, Großes für die Menschheit zu schaffen.",
    "Lasst uns einander zeigen, dass uns dieses Gefühl verbindet."
  ],

  en: [
    "That we are here, on this blue planet deep in space, is an incredible coincidence.",
    "We all share this good fortune.",
    "We are all something special — and yet one.",
    "As part of this community, we have the power to create great things for humanity.",
    "Let us show one another that this feeling connects us."
  ],

  es: [
    "Que estemos aquí, en este planeta azul en lo profundo del espacio, es una coincidencia increíble.",
    "Esta fortuna la compartimos todos.",
    "Todos somos algo especial — y, al mismo tiempo, uno.",
    "Como parte de esta comunidad, tenemos la fuerza para crear grandes cosas para la humanidad.",
    "Mostrémonos unos a otros que este sentimiento nos une."
  ],

  hi: [
    "कि हम यहाँ हैं, इस नीले ग्रह पर, अंतरिक्ष की गहराइयों में — यह एक अद्भुत संयोग है।",
    "यह सौभाग्य हम सभी साझा करते हैं।",
    "हम सभी कुछ विशेष हैं — और फिर भी एक हैं।",
    "इस समुदाय का हिस्सा होकर, हमारे पास मानवता के लिए महान कार्य करने की शक्ति है।",
    "आइए एक-दूसरे को दिखाएँ कि यह भावना हमें जोड़ती है।"
  ],

  zh: [
    "我们能在这里，在浩瀚宇宙深处的这颗蓝色星球上存在，是一个不可思议的巧合。",
    "这份幸运属于我们所有人。",
    "我们每个人都独一无二——却又合而为一。",
    "作为这个共同体的一部分，我们拥有为人类创造伟大事物的力量。",
    "让我们彼此展现，这种感觉将我们连接在一起。"
  ],

  ar: [
    "إن وجودنا هنا، على هذا الكوكب الأزرق في أعماق الكون، هو مصادفة مذهلة.",
    "هذا الحظ نتشاركه جميعًا.",
    "كل واحدٍ منا مميز — ومع ذلك فنحن واحد.",
    "كجزءٍ من هذا المجتمع، نمتلك القدرة على تحقيق أشياء عظيمة للبشرية.",
    "دعونا نُظهر لبعضنا أن هذا الشعور يربطنا."
  ],

  ru: [
    "То, что мы здесь, на этой голубой планете в глубинах космоса, — невероятная случайность.",
    "Это счастье мы разделяем все.",
    "Каждый из нас особенный — и в то же время мы едины.",
    "Будучи частью этого сообщества, мы обладаем силой творить великое для человечества.",
    "Давайте покажем друг другу, что это чувство объединяет нас."
  ]
};

  const UI = {
  en: {
    prev: "Back",
    next: "Next",
    world: "World view",
    card: "Generate map",
    hint: "Click on the map to place or move your light. (One light per browser.)",
    status_set: "Your light is set. You can move it by clicking on the map.",
    status_empty: "Place your light by clicking on the map.",
    status_error_load: "Could not load lights.",
    status_error_save: "Saving failed.",
    status_export: "Creating image…",
    status_done: "Done."
  },

  de: {
    prev: "Zurück",
    next: "Weiter",
    world: "Weltansicht",
    card: "Karte generieren",
    hint: "Klicke auf die Karte, um dein Licht zu setzen oder zu verschieben. (Nur ein Licht pro Browser.)",
    status_set: "Dein Licht ist gesetzt. Du kannst es durch Klicken verschieben.",
    status_empty: "Setze dein Licht mit einem Klick auf die Karte.",
    status_error_load: "Konnte Lichter nicht laden.",
    status_error_save: "Speichern fehlgeschlagen.",
    status_export: "Erzeuge Bild…",
    status_done: "Fertig."
  },

  es: {
    prev: "Atrás",
    next: "Siguiente",
    world: "Vista mundial",
    card: "Generar mapa",
    hint: "Haz clic en el mapa para colocar o mover tu luz. (Una luz por navegador.)",
    status_set: "Tu luz está colocada. Puedes moverla haciendo clic.",
    status_empty: "Coloca tu luz haciendo clic en el mapa.",
    status_error_load: "No se pudieron cargar las luces.",
    status_error_save: "Error al guardar.",
    status_export: "Creando imagen…",
    status_done: "Listo."
  },

  hi: {
    prev: "पीछे",
    next: "आगे",
    world: "विश्व दृश्य",
    card: "मानचित्र बनाएँ",
    hint: "अपनी रोशनी लगाने या स्थान बदलने के लिए मानचित्र पर क्लिक करें।",
    status_set: "आपकी रोशनी सेट है। आप इसे क्लिक करके बदल सकते हैं।",
    status_empty: "मानचित्र पर क्लिक करके अपनी रोशनी लगाएँ।",
    status_error_load: "रोशनियाँ लोड नहीं हो सकीं।",
    status_error_save: "सहेजना विफल रहा।",
    status_export: "चित्र बनाया जा रहा है…",
    status_done: "पूर्ण।"
  },

  zh: {
    prev: "返回",
    next: "继续",
    world: "世界视图",
    card: "生成地图",
    hint: "点击地图以放置或移动你的光点。（每个浏览器一个）",
    status_set: "你的光点已设置，可以点击移动。",
    status_empty: "点击地图放置你的光点。",
    status_error_load: "无法加载光点。",
    status_error_save: "保存失败。",
    status_export: "正在生成图片…",
    status_done: "完成。"
  },

  ar: {
    prev: "رجوع",
    next: "التالي",
    world: "عرض العالم",
    card: "إنشاء الخريطة",
    hint: "انقر على الخريطة لوضع الضوء أو تحريكه.",
    status_set: "تم وضع ضوئك. يمكنك تحريكه بالنقر.",
    status_empty: "ضع ضوءك بالنقر على الخريطة.",
    status_error_load: "تعذر تحميل الأضواء.",
    status_error_save: "فشل الحفظ.",
    status_export: "جارٍ إنشاء الصورة…",
    status_done: "تم."
  },

  ru: {
    prev: "Назад",
    next: "Далее",
    world: "Вид мира",
    card: "Создать карту",
    hint: "Нажмите на карту, чтобы разместить или переместить свет.",
    status_set: "Ваш свет установлен. Вы можете переместить его.",
    status_empty: "Нажмите на карту, чтобы установить свет.",
    status_error_load: "Не удалось загрузить огни.",
    status_error_save: "Ошибка сохранения.",
    status_export: "Создание изображения…",
    status_done: "Готово."
  }
};

const UI_TEXT = UI[LANG] || UI.en;

const tpTexts = TP[LANG] || TP.en;

// Optional: set <html lang="..."> for accessibility
document.documentElement.lang = LANG;

const WORD_MS = 240;
const SENTENCE_PAUSE = 900;

let tpIndex = 0, tpWordIdx = 0, tpTimer = null;
const tpTextEl = document.getElementById("tp-text");
const tpBarEl  = document.getElementById("tp-bar");

function renderSentence(sentence){
  const tokens = sentence.split(/(\s+)/);
  tpTextEl.innerHTML = tokens.map(t => {
    if (/^\s+$/.test(t)) return `<span class="tp-space">${t}</span>`;
    return `<span class="tp-word">${t}</span>`;
  }).join("");
}
function markProgress(activeWordIdx){
  const wordSpans = Array.from(tpTextEl.querySelectorAll(".tp-word"));
  wordSpans.forEach((w, i) => {
    w.classList.remove("active");
    if (i <= activeWordIdx) w.classList.add("done");
    else w.classList.remove("done");
  });
  if (wordSpans[activeWordIdx]) wordSpans[activeWordIdx].classList.add("active");
}
function updateProgress(){
  tpBarEl.style.width = `${100 * (tpIndex + 1) / tpTexts.length}%`;
}
function playSentence(idx, auto=true){
  clearInterval(tpTimer);
  tpIndex = idx; tpWordIdx = 0;
  renderSentence(tpTexts[tpIndex]);
  updateProgress();

  const words = tpTexts[tpIndex].split(/\s+/).filter(Boolean);
  markProgress(0);

  tpTimer = setInterval(() => {
    tpWordIdx++;
    if (tpWordIdx < words.length) markProgress(tpWordIdx);
    else {
      clearInterval(tpTimer);
      markProgress(words.length - 1);
      if(auto){
        setTimeout(() => {
          if(tpIndex < tpTexts.length - 1) playSentence(tpIndex + 1, true);
        }, SENTENCE_PAUSE);
      }
    }
  }, WORD_MS);
}
document.getElementById("tp-prev").title =
document.getElementById("tp-prev").ariaLabel =
document.getElementById("tp-prev").textContent = "←";

document.getElementById("tp-next").title =
document.getElementById("tp-next").ariaLabel =
document.getElementById("tp-next").textContent = "→";

document.getElementById("btnWorld").textContent = UI_TEXT.world;
document.getElementById("btnCard").textContent = UI_TEXT.card;
document.getElementById("hint").textContent = UI_TEXT.hint;
playSentence(0, true);

/* -------------------------
   2) SUPABASE
-------------------------- */
function uuidv4() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    var r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

const SUPABASE_URL = 'https://gwfqdukbcgtcefqtgnbl.supabase.co';  // <-- DEIN Project URL
const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imd3ZnFkdWtiY2d0Y2VmcXRnbmJsIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njg3MDU2MTMsImV4cCI6MjA4NDI4MTYxM30.ePyuDxhVoc1ol5lQ8JbRKaybgpEPozBR3Wf71oFj040';  // <-- DEIN anon public key

const statusEl = document.getElementById("status");
function setStatus(msg){ statusEl.textContent = msg || ""; }
function setStatus(key){ statusEl.textContent = UI_TEXT[key] || ""; }

const sb = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

let session = localStorage.getItem('myLightSession');
if(!session) { session = uuidv4(); localStorage.setItem('myLightSession', session); }

/* -------------------------
   3) MAP (WICHTIG: zuerst map initialisieren!)
-------------------------- */
const WORLD_BOUNDS = L.latLngBounds(L.latLng(-60, -180), L.latLng(85, 180));
const WORLD_VIEW = { center: [20, 0], zoom: 2.0 };

const map = L.map('map', {
  zoomControl: true,
  preferCanvas: true,
  worldCopyJump: false,
  zoomSnap: 0.25,
  zoomDelta: 0.25,
  maxBounds: WORLD_BOUNDS,
  maxBoundsViscosity: 1.0
}).setView(WORLD_VIEW.center, WORLD_VIEW.zoom);

/* Tile layers (mit/ohne Labels) */
const tileUrlLabels   = 'https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png';
const tileUrlNoLabels = 'https://{s}.basemaps.cartocdn.com/dark_nolabels/{z}/{x}/{y}{r}.png';
// Alternative heller: 'https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png';

const baseWithLabels = L.tileLayer(tileUrlLabels, {
  attribution: '&copy; OpenStreetMap &copy; CARTO',
  maxZoom: 18,
  noWrap: true,
  bounds: WORLD_BOUNDS,
  crossOrigin: true
}).addTo(map);

const baseNoLabels = L.tileLayer(tileUrlNoLabels, {
  attribution: '&copy; OpenStreetMap &copy; CARTO',
  maxZoom: 18,
  noWrap: true,
  bounds: WORLD_BOUNDS,
  crossOrigin: true
});

/* Lights layer */
const canvasRenderer = L.canvas({ padding: 0.5 });
const lightsLayer = L.layerGroup().addTo(map);

// Ghost-Light: folgt dem Cursor, zeigt "hier wird das Licht gesetzt"
const ghost = L.circleMarker([0,0], {
  renderer: canvasRenderer,
  radius: 10,
  stroke: false,
  fill: true,
  fillOpacity: 0.10,
  fillColor: "rgba(255,220,170,1)",
  interactive: false
}).addTo(map);

const ghostCore = L.circleMarker([0,0], {
  renderer: canvasRenderer,
  radius: 2.2,
  stroke: false,
  fill: true,
  fillOpacity: 0.75,
  fillColor: "rgba(255,250,245,1)",
  interactive: false
}).addTo(map);

// nur anzeigen, wenn Maus über der Karte ist
map.on("mouseover", () => {
  ghost.setStyle({ fillOpacity: 0.10 });
  ghostCore.setStyle({ fillOpacity: 0.75 });
});
map.on("mouseout", () => {
  ghost.setStyle({ fillOpacity: 0.0 });
  ghostCore.setStyle({ fillOpacity: 0.0 });
});

// Cursor-Bewegung
map.on("mousemove", (e) => {
  ghost.setLatLng(e.latlng);
  ghostCore.setLatLng(e.latlng);
});
  
/* sehr kleine Punkte für andere */
function addLight(latlng, isMine=false){
  if(!isMine){
    L.circleMarker(latlng, {
      renderer: canvasRenderer,
      radius: 1.35,
      stroke: false,
      fill: true,
      fillOpacity: 0.70,
      fillColor: "rgba(255,250,245,1)",
      interactive: false
    }).addTo(lightsLayer);
    return;
  }
  // mein Punkt minimal größer
  L.circleMarker(latlng, {
    renderer: canvasRenderer,
    radius: 2.6,
    stroke: false,
    fill: true,
    fillOpacity: 0.95,
    fillColor: "rgba(255,250,245,1)",
    interactive: true
  }).addTo(lightsLayer);
}

let allLightPoints = [];

/* Load */
async function loadLights(){
  try{
    const b = map.getBounds();
    const { data, error } = await sb
      .from('lights')
      .select('lat,lng,session') // nicht unbedingt *
      .gte('lat', b.getSouth())
      .lte('lat', b.getNorth())
      .gte('lng', b.getWest())
      .lte('lng', b.getEast());

    if(error) throw error;

    allLightPoints = data || [];
    lightsLayer.clearLayers();

    let mine = null;
    for(const row of allLightPoints){
      const isMine = (row.session === session);
      if(isMine) mine = row;
      addLight([row.lat, row.lng], isMine);
    }
    setStatus(mine ? "status_set" : "status_empty");
  } catch(e){
    console.error(e);
    setStatus("status_error_load");
  }
}

async function loadMyLight(){
  const { data } = await sb.from('lights').select('*').eq('session', session).maybeSingle();
  return data;
}

/* Click: speichern, Zoom bleibt */
map.on('click', async (e) => {
  try{
    const existing = await loadMyLight();
    if(existing){
      await sb.from('lights').update({ lat: e.latlng.lat, lng: e.latlng.lng }).eq('session', session);
    } else {
      await sb.from('lights').insert({ lat: e.latlng.lat, lng: e.latlng.lng, session });
    }
    await loadLights();
  } catch(err){
    console.error(err);
    setStatus("status_error_save");
  }
});

/* Weltansicht Button */
document.getElementById("btnWorld").addEventListener("click", () => {
  map.setView(WORLD_VIEW.center, WORLD_VIEW.zoom, { animate: true });
});

/* Export: Screenshot der Weltansicht, kurz ohne Labels */
function waitTiles(layer){
  return new Promise(resolve => {
    let done = false;
    const finish = () => {
      if(done) return;
      done = true;
      requestAnimationFrame(() => requestAnimationFrame(resolve));
    };
    layer.once('load', finish);
    setTimeout(finish, 1200); // Fallback
  });
}

document.getElementById("btnCard").addEventListener("click", async () => {
  try{
    setStatus("status_export");

    // 1) auf Weltansicht
    map.setView(WORLD_VIEW.center, WORLD_VIEW.zoom, { animate: true });

    // 2) no-labels Layer rein
    if(map.hasLayer(baseWithLabels)) map.removeLayer(baseWithLabels);
    baseNoLabels.addTo(map);

    // 3) warten bis Tiles geladen
    await waitTiles(baseNoLabels);

    // 4) Screenshot
    leafletImage(map, function(err, canvas){
      // 5) Layer zurück
      map.removeLayer(baseNoLabels);
      baseWithLabels.addTo(map);

      if(err){
        console.error(err);
        setStatus("status_error_save");
        alert("status_error_save");
        return;
      }
      const png = canvas.toDataURL("image/png");
      const a = document.createElement("a");
      a.href = png;
      a.download = "weltansicht-ohne-labels.png";
      a.click();
      setStatus("status_done");
    });
  } catch(e){
    console.error(e);
    setStatus("status_error_save");
    alert("status_error_save");
  }
});

/* Start */
loadLights();
setInterval(loadLights, 30000);
</script>
</body>
</html>
