<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Together We Are One</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Supabase -->
  <script src="https://unpkg.com/@supabase/supabase-js@2"></script>

  <!-- PNG Export helper -->
  <script src="https://unpkg.com/leaflet-image@0.4.0/leaflet-image.js"></script>

  <style>
    :root{
      --bg0:#0b0d12;
      --bg1:#121526;
      --card: rgba(255,255,255,0.06);
      --card2: rgba(255,255,255,0.08);
      --stroke: rgba(255,255,255,0.10);

      --ghost: rgba(255,255,255,0.22);
      --text: rgba(255,255,255,0.92);
      --warm: rgba(255,220,170,0.95);

      /* Anzeige-Look (fix, ohne User-Regler) */
      --map-brightness: 0.64;
      --map-contrast: 1.25;
      --map-saturate: 0.0;   /* Graustufe */
      --shade-opacity: 0.90;
      --ocean-tint: rgba(0,0,0,0.38);
    }

    html,body { height:100%; }
    body{
      margin:0;
      color: var(--text);
      background:
        radial-gradient(1200px 700px at 50% 12%, rgba(40,60,110,0.35) 0%, rgba(0,0,0,0) 55%),
        radial-gradient(900px 520px at 20% 8%, rgba(130,90,40,0.18) 0%, rgba(0,0,0,0) 55%),
        linear-gradient(180deg, var(--bg1), var(--bg0));
      font-family: ui-sans-serif, system-ui, -apple-system, "SF Pro Display", "Inter", "Segoe UI", Arial, sans-serif;
      overflow-x:hidden;
    }

    .wrap{
      min-height:100%;
      display:grid;
      grid-template-rows:auto auto 1fr auto;
      gap:14px;
      padding:18px 14px;
      box-sizing:border-box;
      max-width:1100px;
      margin:0 auto;
    }

    /* --- Prompter --- */
    .teleprompter{
      padding:18px 18px 14px 18px;
      border-radius:20px;
      background: linear-gradient(180deg, var(--card2), var(--card));
      border: 1px solid var(--stroke);
      box-shadow: 0 16px 60px rgba(0,0,0,0.35);
      backdrop-filter: blur(10px);
    }
    .tp-text{
      text-align:center;
      font-size: clamp(18px, 2.5vw, 30px);
      line-height:1.45;
      letter-spacing:0.2px;
      margin:0;
      padding:8px 10px 10px 10px;
      min-height:3.2em;
    }
    /* Zeilenumbruch: aktiv */
    .tp-word{
      color: var(--ghost);
      transition: color 160ms ease, filter 160ms ease;
      white-space: normal;
      overflow-wrap: anywhere;
    }
    .tp-space{ white-space: pre; }
    .tp-word.done{
      color: var(--warm);
      filter: drop-shadow(0 0 12px rgba(255,210,140,0.18));
    }
    .tp-word.active{
      color: rgba(255,245,235,0.98);
      filter: drop-shadow(0 0 18px rgba(255,210,140,0.26));
    }

    .tp-meta{
      display:flex; align-items:center; justify-content:center;
      gap:10px; margin-top:8px; user-select:none;
    }
    .tp-btn{
      width:42px; height:42px; border-radius:14px;
      border:1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.85);
      cursor:pointer;
      transition: background 140ms ease, transform 140ms ease;
      font-size:18px; font-weight:700;
    }
    .tp-btn:hover{ background: rgba(255,255,255,0.10); transform: translateY(-1px); }

    .tp-progress{
      width: min(520px, 62vw);
      height:8px;
      border-radius:8px;
      overflow:hidden;
      background: rgba(255,255,255,0.10);
      border:1px solid rgba(255,255,255,0.08);
    }
    .tp-progress-bar{
      height:100%;
      width:0%;
      background: linear-gradient(90deg, rgba(255,220,170,0.65), rgba(255,255,255,0.55));
      transition: width 220ms ease;
    }

    /* --- Map --- */
    .mapWrap{
      position:relative;
      border-radius:20px;
      overflow:hidden;
      border:1px solid rgba(255,255,255,0.10);
      box-shadow: 0 16px 60px rgba(0,0,0,0.35);
      background:#0a0b10;
    }
    #map{ width:100%; height: min(62vh, 520px); }

    /* On-screen: Graustufe + dunkler */
    .leaflet-tile{
      filter:
        grayscale(1)
        brightness(var(--map-brightness))
        contrast(var(--map-contrast))
        saturate(var(--map-saturate));
    }

    .mapTint{
      pointer-events:none;
      position:absolute; inset:0;
      background: var(--ocean-tint);
      mix-blend-mode: multiply;
      opacity:1;
    }
    .mapShade{
      pointer-events:none;
      position:absolute; inset:0;
      opacity: var(--shade-opacity);
      background:
        radial-gradient(900px 420px at 50% 10%, rgba(0,0,0,0.18), rgba(0,0,0,0.86) 65%),
        radial-gradient(700px 520px at 10% 80%, rgba(0,0,0,0.12), rgba(0,0,0,0.78) 72%),
        linear-gradient(180deg, rgba(0,0,0,0.14), rgba(0,0,0,0.70));
      mix-blend-mode: multiply;
    }

    .hud{
      position:absolute;
      left:12px; top:12px;
      display:flex; gap:10px;
      z-index:500;
      flex-wrap:wrap;
      align-items:center;
    }
    .hud button{
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.24);
      color: rgba(255,255,255,0.92);
      cursor:pointer;
      backdrop-filter: blur(10px);
      transition: background 140ms ease, transform 140ms ease;
      font-weight:650;
      letter-spacing:0.2px;
    }
    .hud button:hover{ background: rgba(0,0,0,0.32); transform: translateY(-1px); }

    .hint{ text-align:center; margin:4px 0 0 0; color: rgba(255,255,255,0.60); font-size:14px; }
    .status{ text-align:center; color: rgba(255,255,255,0.70); font-size:13px; margin-top:6px; }

    @media (max-width:600px){
      .wrap{ padding:12px 10px; }
      .teleprompter{ padding:14px 12px 12px 12px; border-radius:18px; }
      .tp-btn{ width:40px; height:40px; border-radius:14px; }
      #map{ height:52vh; }
    }
  </style>
</head>

<body>
  <div class="wrap">

    <div class="teleprompter" aria-label="Text">
      <p class="tp-text" id="tp-text"></p>
      <div class="tp-meta">
        <button class="tp-btn" id="tp-prev" title="Zurück" aria-label="Zurück">←</button>
        <div class="tp-progress"><div class="tp-progress-bar" id="tp-bar"></div></div>
        <button class="tp-btn" id="tp-next" title="Weiter" aria-label="Weiter">→</button>
      </div>
    </div>

    <div class="mapWrap" id="mapWrap">
      <div class="hud">
        <button id="btnWorld" title="Ein Erdball (ohne Wrap / ohne doppelte Kontinente)">Weltansicht</button>
        <button id="btnCard" title="Screenshot vom Erdball (Graustufe, dunkel, mit Lichtern)">Karte generieren</button>
      </div>

      <div id="map"></div>
      <div class="mapTint"></div>
      <div class="mapShade"></div>
    </div>

    <p class="hint">Klicke auf die Karte, um dein Licht zu setzen oder zu verschieben. (Nur ein Licht pro Browser.)</p>
    <p class="status" id="status"></p>
  </div>

<script>
/* -------------------------
   PROMPTER
-------------------------- */
const tpTexts = [
  "Manchmal schauen wir in den Himmel.",
  "Vielleicht sehen wir einen Stern, den Mond, ferne Galaxien.",
  "Für einen Moment wird uns bewusst, wie klein unser Planet ist.",
  "Wie selten – vielleicht sogar einzigartig – das Leben hier ist.",
  "Auf diesem winzigen Punkt im Weltall teilen wir unser Leben.",
  "Jeder von uns mit einer eigenen Geschichte, aber doch alle miteinander verbunden.",
  "Nicht durch Herkunft, Sprache oder Grenzen – sondern durch das Glück, gemeinsam hier zu sein.",
  "Manche Menschen spüren in solchen Momenten, dass wir eigentlich eine einzige Gemeinschaft sind.",
  "Dass uns mehr verbindet als trennt.",
  "Hast du das auch schon einmal gefühlt?",
  "Helf’ uns, dieses Gefühl sichtbar zu machen!"
];

const WORD_MS = 240;
const SENTENCE_PAUSE = 900;

let tpIndex = 0, tpWordIdx = 0, tpTimer = null;
const tpTextEl = document.getElementById("tp-text");
const tpBarEl  = document.getElementById("tp-bar");

function renderSentence(sentence){
  const tokens = sentence.split(/(\s+)/);
  tpTextEl.innerHTML = tokens.map(t => {
    if (/^\s+$/.test(t)) return `<span class="tp-space">${t}</span>`;
    return `<span class="tp-word">${t}</span>`;
  }).join("");
}
function markProgress(activeWordIdx){
  const wordSpans = Array.from(tpTextEl.querySelectorAll(".tp-word"));
  wordSpans.forEach((w, i) => {
    w.classList.remove("active");
    if (i <= activeWordIdx) w.classList.add("done");
    else w.classList.remove("done");
  });
  if (wordSpans[activeWordIdx]) wordSpans[activeWordIdx].classList.add("active");
}
function updateProgress(){
  tpBarEl.style.width = `${100 * (tpIndex + 1) / tpTexts.length}%`;
}
function playSentence(idx, auto=true){
  clearInterval(tpTimer);
  tpIndex = idx; tpWordIdx = 0;
  renderSentence(tpTexts[tpIndex]);
  updateProgress();

  const words = tpTexts[tpIndex].split(/\s+/).filter(Boolean);
  markProgress(0);

  tpTimer = setInterval(() => {
    tpWordIdx++;
    if (tpWordIdx < words.length) markProgress(tpWordIdx);
    else {
      clearInterval(tpTimer);
      markProgress(words.length - 1);
      if(auto){
        setTimeout(() => {
          if(tpIndex < tpTexts.length - 1) playSentence(tpIndex + 1, true);
        }, SENTENCE_PAUSE);
      }
    }
  }, WORD_MS);
}
document.getElementById("tp-next").onclick = () => { if(tpIndex < tpTexts.length - 1) playSentence(tpIndex + 1, false); };
document.getElementById("tp-prev").onclick = () => { if(tpIndex > 0) playSentence(tpIndex - 1, false); };
playSentence(0, true);

/* -------------------------
   SUPABASE
-------------------------- */
function uuidv4() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    var r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

const SUPABASE_URL = 'https://gwfqdukbcgtcefqtgnbl.supabase.co';  // <-- DEIN Project URL
const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imd3ZnFkdWtiY2d0Y2VmcXRnbmJsIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njg3MDU2MTMsImV4cCI6MjA4NDI4MTYxM30.ePyuDxhVoc1ol5lQ8JbRKaybgpEPozBR3Wf71oFj040';  // <-- DEIN anon public key

const statusEl = document.getElementById("status");
function setStatus(msg){ statusEl.textContent = msg || ""; }

const sb = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

let session = localStorage.getItem('myLightSession');
if(!session) { session = uuidv4(); localStorage.setItem('myLightSession', session); }

/* -------------------------
   MAP: ein Erdball, kein Wrap, keine doppelten Kontinente
-------------------------- */
const WORLD_BOUNDS = L.latLngBounds(L.latLng(-60, -180), L.latLng(85, 180));
const WORLD_VIEW = { center: [20, 0], zoom: 2.0 };  // "ein Erdball" (2D) — ruhig & weit
const tileUrl = 'https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png';

const map = L.map('map', {
  zoomControl: true,
  worldCopyJump: false,      // wichtig: nicht springen/wrappen
  preferCanvas: true,
  zoomSnap: 0.25,
  zoomDelta: 0.25,
  maxBounds: WORLD_BOUNDS,
  maxBoundsViscosity: 1.0
}).setView(WORLD_VIEW.center, WORLD_VIEW.zoom);

L.tileLayer(tileUrl, {
  attribution: '&copy; OpenStreetMap &copy; CARTO',
  maxZoom: 18,
  noWrap: true,             // wichtig: keine zweite Welt zeichnen
  bounds: WORLD_BOUNDS,
  crossOrigin: true
}).addTo(map);

const canvasRenderer = L.canvas({ padding: 0.5 });
const lightsLayer = L.layerGroup().addTo(map);

/* Punkt-Design:
   - andere: sehr klein (nur Orientierung)
   - mein Punkt: etwas größer, deutlicher Glow
*/
function addLight(latlng, isMine=false){
  if(!isMine){
    // minimaler Glow
    L.circleMarker(latlng, {
      renderer: canvasRenderer,
      radius: 3.2,
      stroke: false,
      fill: true,
      fillOpacity: 0.06,
      fillColor: "rgba(255,220,170,1)",
      interactive: false
    }).addTo(lightsLayer);

    // winziger Kern
    L.circleMarker(latlng, {
      renderer: canvasRenderer,
      radius: 1.35,
      stroke: false,
      fill: true,
      fillOpacity: 0.70,
      fillColor: "rgba(255,250,245,1)",
      interactive: false
    }).addTo(lightsLayer);
    return;
  }

  // mein Glow (sichtbarer)
  L.circleMarker(latlng, {
    renderer: canvasRenderer,
    radius: 10,
    stroke: false,
    fill: true,
    fillOpacity: 0.14,
    fillColor: "rgba(255,210,150,1)",
    interactive: false
  }).addTo(lightsLayer);

  L.circleMarker(latlng, {
    renderer: canvasRenderer,
    radius: 6.2,
    stroke: false,
    fill: true,
    fillOpacity: 0.16,
    fillColor: "rgba(255,235,200,1)",
    interactive: false
  }).addTo(lightsLayer);

  L.circleMarker(latlng, {
    renderer: canvasRenderer,
    radius: 2.8,
    stroke: false,
    fill: true,
    fillOpacity: 0.95,
    fillColor: "rgba(255,250,245,1)",
    interactive: true
  }).addTo(lightsLayer);
}

let allLightPoints = [];

async function loadLights(){
  try{
    const { data, error } = await sb.from('lights').select('*');
    if(error) throw error;

    allLightPoints = data || [];
    lightsLayer.clearLayers();

    let mine = null;
    for(const row of allLightPoints){
      const isMine = (row.session === session);
      if(isMine) mine = row;
      addLight([row.lat, row.lng], isMine);
    }
    setStatus(mine ? "Dein Licht ist gesetzt. Du kannst es durch Klicken verschieben." : "Setze dein Licht mit einem Klick auf die Karte.");
  } catch(e){
    console.error(e);
    setStatus("Konnte Lichter nicht laden. Prüfe Supabase URL/Key und Tabelle „lights“.");
  }
}

async function loadMyLight(){
  const { data } = await sb.from('lights').select('*').eq('session', session).maybeSingle();
  return data;
}

/* Klick speichert/verschiebt, Zoom bleibt wie gewählt */
map.on('click', async (e) => {
  try{
    const existing = await loadMyLight();
    if(existing){
      await sb.from('lights').update({ lat: e.latlng.lat, lng: e.latlng.lng }).eq('session', session);
    } else {
      await sb.from('lights').insert({ lat: e.latlng.lat, lng: e.latlng.lng, session });
    }
    await loadLights();
  } catch(err){
    console.error(err);
    setStatus("Speichern fehlgeschlagen. Prüfe Supabase-Rechte (RLS/Policies).");
  }
});

document.getElementById("btnWorld").addEventListener("click", () => {
  map.setView(WORLD_VIEW.center, WORLD_VIEW.zoom, { animate: true });
});

/* -------------------------
   EXPORT: Zoom auf "ein Erdball" -> leafletImage -> Canvas Postprocess
   (Graustufe + dunkel + Vignette + Globus-Maske)
-------------------------- */

/* Diese Werte bestimmen die Export-Dunkelheit (soll wie Anzeige wirken).
   Du kannst hier noch dunkler gehen, ohne UI zu ändern: */
const EXPORT_BRIGHTNESS = 0.55; // < 0.55 = dunkler
const EXPORT_CONTRAST   = 1.25;
const EXPORT_VIGNETTE   = 0.65; // 0..1
const EXPORT_GLOBE_FILL = 0;    // Hintergrund (schwarz)

function clamp(v){ return Math.max(0, Math.min(255, v)); }

function applyNightGlobeLook(srcCanvas){
  const w = srcCanvas.width, h = srcCanvas.height;
  const out = document.createElement('canvas');
  out.width = w; out.height = h;
  const octx = out.getContext('2d');

  // draw source
  octx.drawImage(srcCanvas, 0, 0);

  const img = octx.getImageData(0, 0, w, h);
  const d = img.data;

  const cx = w * 0.5;
  const cy = h * 0.5;
  const r = Math.min(w, h) * 0.46;           // Globus-Radius
  const r2 = r * r;
  const vignStart = r * 0.55;               // ab hier Vignette stärker
  const vignRange = r - vignStart;

  // Contrast helper
  const contrast = EXPORT_CONTRAST;
  const b = EXPORT_BRIGHTNESS;

  for(let y=0; y<h; y++){
    for(let x=0; x<w; x++){
      const i = (y*w + x)*4;
      const dx = x - cx;
      const dy = y - cy;
      const dist2 = dx*dx + dy*dy;

      if(dist2 > r2){
        // außerhalb: schwarz (runde Globus-Maske)
        d[i] = EXPORT_GLOBE_FILL;
        d[i+1] = EXPORT_GLOBE_FILL;
        d[i+2] = EXPORT_GLOBE_FILL;
        d[i+3] = 255;
        continue;
      }

      // rgb -> gray
      const R = d[i], G = d[i+1], B = d[i+2];
      let gray = 0.2126*R + 0.7152*G + 0.0722*B;

      // Dunkelheit
      gray = gray * b;

      // Kontrast (um Lichter abzuheben)
      gray = (gray - 128) * contrast + 128;

      // Vignette (zum Rand dunkler)
      const dist = Math.sqrt(dist2);
      if(dist > vignStart){
        const t = (dist - vignStart) / Math.max(1, vignRange);
        const v = 1 - (EXPORT_VIGNETTE * t * t);
        gray *= v;
      }

      // "Lichter" etwas poppen lassen (helles bleibt hell)
      if(gray > 160) gray = Math.min(255, gray * 1.12);

      gray = clamp(gray);
      d[i] = d[i+1] = d[i+2] = gray;
      d[i+3] = 255;
    }
  }

  octx.putImageData(img, 0, 0);

  // sanfter "Atmosphärenrand" (grau) – optional, aber macht Globus echter
  octx.save();
  octx.globalCompositeOperation = 'lighter';
  const grad = octx.createRadialGradient(cx, cy, r*0.92, cx, cy, r*1.02);
  grad.addColorStop(0, 'rgba(255,255,255,0)');
  grad.addColorStop(1, 'rgba(255,255,255,0.10)');
  octx.fillStyle = grad;
  octx.beginPath();
  octx.arc(cx, cy, r*1.01, 0, Math.PI*2);
  octx.fill();
  octx.restore();

  return out;
}

function waitForMapSettled(tileLayer){
  return new Promise(resolve => {
    let moved = false, tiles = false;

    const done = () => {
      if(moved && tiles){
        requestAnimationFrame(() => requestAnimationFrame(resolve));
      }
    };

    map.once('moveend', () => { moved = true; done(); });
    tileLayer.once('load', () => { tiles = true; done(); });

    // Fallback falls Cache/Events komisch: nach 1.2s weiter
    setTimeout(() => { moved = true; tiles = true; done(); }, 1200);
  });
}

document.getElementById("btnCard").addEventListener("click", async () => {
  try{
    setStatus("Erzeuge Erdball…");

    // View merken, danach wiederherstellen
    const prevCenter = map.getCenter();
    const prevZoom = map.getZoom();

    // 1) auf "ein Erdball" rauszoomen
    map.setView(WORLD_VIEW.center, WORLD_VIEW.zoom, { animate: true });

    // 2) warten bis Tiles + Move fertig
    const tileLayer = map._layers[Object.keys(map._layers).find(k => map._layers[k] instanceof L.TileLayer)];
    if(tileLayer) await waitForMapSettled(tileLayer);

    // 3) Canvas snapshot
    leafletImage(map, function(err, canvas) {
      // View zurück
      map.setView(prevCenter, prevZoom, { animate: true });

      if(err){
        console.error(err);
        alert("Export fehlgeschlagen.");
        setStatus("Export fehlgeschlagen.");
        return;
      }

      // 4) Postprocess: Globus-Maske + Night-Look
      const out = applyNightGlobeLook(canvas);

      // 5) Download
      const png = out.toDataURL("image/png");
      const a = document.createElement("a");
      a.href = png;
      a.download = "erde-bei-nacht.png";
      a.click();

      setStatus("Fertig.");
    });
  } catch(e){
    console.error(e);
    alert("Export fehlgeschlagen.");
    setStatus("Export fehlgeschlagen.");
  }
});

/* Start */
loadLights();
setInterval(loadLights, 30000);
</script>
</body>
</html>
