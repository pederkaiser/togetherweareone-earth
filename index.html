<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Together We Are One</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Supabase -->
  <script src="https://unpkg.com/@supabase/supabase-js@2"></script>

  <!-- PNG Export -->
  <script src="https://unpkg.com/leaflet-image@0.4.0/leaflet-image.js"></script>

  <style>
    :root{
      --bg0:#0b0d12;
      --bg1:#121526;
      --card: rgba(255,255,255,0.06);
      --card2: rgba(255,255,255,0.08);
      --stroke: rgba(255,255,255,0.10);

      --ghost: rgba(255,255,255,0.22);
      --text: rgba(255,255,255,0.92);
      --warm: rgba(255,220,170,0.95);

      /* =========================
         FIX: "dunkelste" Einstellung fest verdrahtet
         (kein Slider mehr, User kann es nicht verändern)
         ========================= */
      --map-brightness: 0.56;   /* dunkler als vorher */
      --map-contrast: 1.25;
      --map-saturate: 0.00;     /* 0 = Graustufe */
      --shade-opacity: 0.90;    /* starker Night-Film */
      --ocean-tint: rgba(0,0,0,0.42);
    }

    html,body { height:100%; }
    body{
      margin: 0;
      color: var(--text);
      background:
        radial-gradient(1200px 700px at 50% 12%, rgba(40,60,110,0.35) 0%, rgba(0,0,0,0) 55%),
        radial-gradient(900px 520px at 20% 8%, rgba(130,90,40,0.18) 0%, rgba(0,0,0,0) 55%),
        linear-gradient(180deg, var(--bg1), var(--bg0));
      font-family: ui-sans-serif, system-ui, -apple-system, "SF Pro Display", "Inter", "Segoe UI", Arial, sans-serif;
      overflow-x: hidden;
    }

    .wrap{
      min-height: 100%;
      display: grid;
      grid-template-rows: auto auto 1fr auto;
      gap: 14px;
      padding: 18px 14px 18px 14px;
      box-sizing: border-box;
      max-width: 1100px;
      margin: 0 auto;
    }

    /* --- Prompter --- */
    .teleprompter{
      padding: 18px 18px 14px 18px;
      border-radius: 20px;
      background: linear-gradient(180deg, var(--card2), var(--card));
      border: 1px solid var(--stroke);
      box-shadow: 0 16px 60px rgba(0,0,0,0.35);
      backdrop-filter: blur(10px);
    }

    .tp-text{
      text-align: center;
      font-size: clamp(18px, 2.5vw, 30px);
      line-height: 1.45;
      letter-spacing: 0.2px;
      margin: 0;
      padding: 8px 10px 10px 10px;
      min-height: 3.2em;
    }

    /* Zeilenumbruch: aktiv */
    .tp-word{
      color: var(--ghost);
      transition: color 160ms ease, filter 160ms ease;
      white-space: normal;
      overflow-wrap: anywhere;
    }
    .tp-space{ white-space: pre; }

    .tp-word.done{
      color: var(--warm);
      filter: drop-shadow(0 0 12px rgba(255,210,140,0.18));
    }
    .tp-word.active{
      color: rgba(255,245,235,0.98);
      filter: drop-shadow(0 0 18px rgba(255,210,140,0.26));
    }

    .tp-meta{
      display:flex; align-items:center; justify-content:center;
      gap: 10px; margin-top: 8px; user-select:none;
    }
    .tp-btn{
      width: 42px; height: 42px; border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.85);
      cursor: pointer;
      transition: background 140ms ease, transform 140ms ease;
      font-size: 18px; font-weight: 700;
    }
    .tp-btn:hover{ background: rgba(255,255,255,0.10); transform: translateY(-1px); }

    .tp-progress{
      width: min(520px, 62vw);
      height: 8px;
      border-radius: 8px;
      overflow:hidden;
      background: rgba(255,255,255,0.10);
      border: 1px solid rgba(255,255,255,0.08);
    }
    .tp-progress-bar{
      height:100%;
      width: 0%;
      background: linear-gradient(90deg, rgba(255,220,170,0.65), rgba(255,255,255,0.55));
      transition: width 220ms ease;
    }

    /* --- Map --- */
    .mapWrap{
      position: relative;
      border-radius: 20px;
      overflow: hidden;
      border: 1px solid rgba(255,255,255,0.10);
      box-shadow: 0 16px 60px rgba(0,0,0,0.35);
      background: #0a0b10;
    }
    #map{ width: 100%; height: min(62vh, 520px); }

    /* FIX: Graustufe + Helligkeit/Look sind fest (wie Export) */
    .leaflet-tile{
      filter:
        grayscale(1)
        brightness(var(--map-brightness))
        contrast(var(--map-contrast))
        saturate(var(--map-saturate));
    }

    .mapTint{
      pointer-events:none;
      position:absolute; inset:0;
      background: var(--ocean-tint);
      mix-blend-mode: multiply;
      opacity: 1;
    }
    .mapShade{
      pointer-events:none;
      position:absolute; inset:0;
      opacity: var(--shade-opacity);
      background:
        radial-gradient(900px 420px at 50% 10%, rgba(0,0,0,0.18), rgba(0,0,0,0.86) 65%),
        radial-gradient(700px 520px at 10% 80%, rgba(0,0,0,0.12), rgba(0,0,0,0.78) 72%),
        linear-gradient(180deg, rgba(0,0,0,0.14), rgba(0,0,0,0.70));
      mix-blend-mode: multiply;
    }

    .hud{
      position:absolute;
      left: 12px;
      top: 12px;
      display:flex;
      gap: 10px;
      z-index: 500;
      flex-wrap: wrap;
      align-items: center;
    }
    .hud button{
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.24);
      color: rgba(255,255,255,0.92);
      cursor: pointer;
      backdrop-filter: blur(10px);
      transition: background 140ms ease, transform 140ms ease;
      font-weight: 650;
      letter-spacing: 0.2px;
    }
    .hud button:hover{ background: rgba(0,0,0,0.32); transform: translateY(-1px); }

    .hint{ text-align:center; margin: 4px 0 0 0; color: rgba(255,255,255,0.60); font-size: 14px; }
    .status{ text-align:center; color: rgba(255,255,255,0.70); font-size: 13px; margin-top: 6px; }

    /* Offscreen Export Map (unsichtbar, unabhängig von Browser-Ansicht) */
    #exportStage{
      position: fixed;
      left: -99999px;
      top: 0;
      width: 1800px;     /* Export-Auflösung */
      height: 1000px;    /* Export-Auflösung */
      background: #000;
      z-index: -1;
      overflow: hidden;
      border-radius: 24px;
    }
    #exportMap{
      width: 1800px;
      height: 1000px;
    }
    #exportStage .mapTint,
    #exportStage .mapShade{
      position:absolute;
      inset:0;
      pointer-events:none;
    }
    #exportStage .mapTint{ background: var(--ocean-tint); mix-blend-mode: multiply; }
    #exportStage .mapShade{ opacity: var(--shade-opacity); background:
      radial-gradient(1200px 700px at 50% 10%, rgba(0,0,0,0.18), rgba(0,0,0,0.90) 70%),
      linear-gradient(180deg, rgba(0,0,0,0.16), rgba(0,0,0,0.72));
      mix-blend-mode: multiply;
    }

    @media (max-width: 600px){
      .wrap{ padding: 12px 10px; }
      .teleprompter{ padding: 14px 12px 12px 12px; border-radius: 18px; }
      .tp-btn{ width: 40px; height: 40px; border-radius: 14px; }
      #map{ height: 52vh; }
    }
  </style>
</head>

<body>
  <div class="wrap">

    <div class="teleprompter" aria-label="Text">
      <p class="tp-text" id="tp-text"></p>
      <div class="tp-meta">
        <button class="tp-btn" id="tp-prev" title="Zurück" aria-label="Zurück">←</button>
        <div class="tp-progress"><div class="tp-progress-bar" id="tp-bar"></div></div>
        <button class="tp-btn" id="tp-next" title="Weiter" aria-label="Weiter">→</button>
      </div>
    </div>

    <div class="mapWrap">
      <div class="hud">
        <button id="btnWorld" title="Weltansicht (ohne reinzuzoomen)">Weltansicht</button>
        <button id="btnCard" title="PNG als Weltkarte generieren (unabhängig vom Browser-Zoom)">Karte generieren</button>
      </div>

      <div id="map"></div>
      <div class="mapTint"></div>
      <div class="mapShade"></div>
    </div>

    <p class="hint">Klicke auf die Karte, um dein Licht zu setzen oder zu verschieben. (Nur ein Licht pro Browser.)</p>
    <p class="status" id="status"></p>
  </div>

  <!-- Offscreen Export Stage -->
  <div id="exportStage">
    <div id="exportMap"></div>
    <div class="mapTint"></div>
    <div class="mapShade"></div>
  </div>

<script>
/* -------------------------
   PROMPTER
-------------------------- */
const tpTexts = [
  "Manchmal schauen wir in den Himmel.",
  "Vielleicht sehen wir einen Stern, den Mond, ferne Galaxien.",
  "Für einen Moment wird uns bewusst, wie klein unser Planet ist.",
  "Wie selten – vielleicht sogar einzigartig – das Leben hier ist.",
  "Auf diesem winzigen Punkt im Weltall teilen wir unser Leben.",
  "Jeder von uns mit einer eigenen Geschichte, aber doch alle miteinander verbunden.",
  "Nicht durch Herkunft, Sprache oder Grenzen – sondern durch das Glück, gemeinsam hier zu sein.",
  "Manche Menschen spüren in solchen Momenten, dass wir eigentlich eine einzige Gemeinschaft sind.",
  "Dass uns mehr verbindet als trennt.",
  "Hast du das auch schon einmal gefühlt?",
  "Helf’ uns, dieses Gefühl sichtbar zu machen!"
];

const WORD_MS = 240;
const SENTENCE_PAUSE = 900;

let tpIndex = 0;
let tpWordIdx = 0;
let tpTimer = null;

const tpTextEl = document.getElementById("tp-text");
const tpBarEl  = document.getElementById("tp-bar");

function renderSentence(sentence){
  const tokens = sentence.split(/(\s+)/);
  tpTextEl.innerHTML = tokens.map(t => {
    if (/^\s+$/.test(t)) return `<span class="tp-space">${t}</span>`;
    return `<span class="tp-word">${t}</span>`;
  }).join("");
}

function markProgress(activeWordIdx){
  const wordSpans = Array.from(tpTextEl.querySelectorAll(".tp-word"));
  wordSpans.forEach((w, i) => {
    w.classList.remove("active");
    if (i <= activeWordIdx) w.classList.add("done");
    else w.classList.remove("done");
  });
  if (wordSpans[activeWordIdx]) wordSpans[activeWordIdx].classList.add("active");
}

function updateProgress(){
  tpBarEl.style.width = `${100 * (tpIndex + 1) / tpTexts.length}%`;
}

function playSentence(idx, auto=true){
  clearInterval(tpTimer);
  tpIndex = idx;
  tpWordIdx = 0;
  renderSentence(tpTexts[tpIndex]);
  updateProgress();

  const words = tpTexts[tpIndex].split(/\s+/).filter(Boolean);
  markProgress(0);

  tpTimer = setInterval(() => {
    tpWordIdx++;
    if (tpWordIdx < words.length){
      markProgress(tpWordIdx);
    } else {
      clearInterval(tpTimer);
      markProgress(words.length - 1);
      if(auto){
        setTimeout(() => {
          if(tpIndex < tpTexts.length - 1) playSentence(tpIndex + 1, true);
        }, SENTENCE_PAUSE);
      }
    }
  }, WORD_MS);
}

document.getElementById("tp-next").onclick = () => {
  if(tpIndex < tpTexts.length - 1) playSentence(tpIndex + 1, false);
};
document.getElementById("tp-prev").onclick = () => {
  if(tpIndex > 0) playSentence(tpIndex - 1, false);
};
playSentence(0, true);

/* -------------------------
   MAP + SUPABASE
-------------------------- */
function uuidv4() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    var r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

const SUPABASE_URL = 'https://gwfqdukbcgtcefqtgnbl.supabase.co';  // <-- DEIN Project URL
const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imd3ZnFkdWtiY2d0Y2VmcXRnbmJsIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njg3MDU2MTMsImV4cCI6MjA4NDI4MTYxM30.ePyuDxhVoc1ol5lQ8JbRKaybgpEPozBR3Wf71oFj040';  // <-- DEIN anon public key

const statusEl = document.getElementById("status");
function setStatus(msg){ statusEl.textContent = msg || ""; }

const sb = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

let session = localStorage.getItem('myLightSession');
if(!session) { session = uuidv4(); localStorage.setItem('myLightSession', session); }

/* World framing:
   Wir erzwingen für "Welt" ein Bounds, das wirklich die ganze Welt zeigt.
   (Leaflet schneidet sonst je nach Aspect Ratio.) */
const WORLD_BOUNDS = L.latLngBounds(
  L.latLng(-60, -180),
  L.latLng( 85,  180)
);
const WORLD_FIT_OPTS = { animate: true, duration: 0.9, padding: [20,20], maxZoom: 2 };

const map = L.map('map', {
  zoomControl: true,
  worldCopyJump: true,
  preferCanvas: true
}).fitBounds(WORLD_BOUNDS, { animate:false, padding:[20,20], maxZoom: 2 });

/* Tiles: Voyager (Kontinente/Umrisse).
   Wichtig für leaflet-image: crossOrigin setzen. */
const tileUrl = 'https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png';

L.tileLayer(tileUrl, {
  attribution: '&copy; OpenStreetMap &copy; CARTO',
  maxZoom: 18,
  crossOrigin: true
}).addTo(map);

/* Lichter: wie "Straßenlaternen aus dem All" */
const canvasRenderer = L.canvas({ padding: 0.5 });
const lightsLayer = L.layerGroup().addTo(map);

function addGlowLight(layerGroup, latlng, isMine=false){
  // großer weicher Glow
  L.circleMarker(latlng, {
    renderer: canvasRenderer,
    radius: isMine ? 14 : 12,
    stroke: false,
    fill: true,
    fillOpacity: 0.14,
    fillColor: "rgba(255,210,150,1)",
    interactive: false
  }).addTo(layerGroup);

  // mittlerer Glow
  L.circleMarker(latlng, {
    renderer: canvasRenderer,
    radius: isMine ? 8 : 7,
    stroke: false,
    fill: true,
    fillOpacity: 0.18,
    fillColor: "rgba(255,230,190,1)",
    interactive: false
  }).addTo(layerGroup);

  // Kern
  L.circleMarker(latlng, {
    renderer: canvasRenderer,
    radius: isMine ? 3.6 : 2.8,
    stroke: false,
    fill: true,
    fillOpacity: 0.96,
    fillColor: "rgba(255,250,245,1)",
    interactive: isMine
  }).addTo(layerGroup);
}

let allLightPoints = [];

async function loadLights() {
  try{
    const { data, error } = await sb.from('lights').select('*');
    if(error) throw error;

    allLightPoints = data || [];
    lightsLayer.clearLayers();

    let mine = null;
    for (const row of allLightPoints){
      const isMine = (row.session === session);
      if(isMine) mine = row;
      addGlowLight(lightsLayer, [row.lat, row.lng], isMine);
    }

    setStatus(mine ? "Dein Licht ist gesetzt. Du kannst es durch Klicken verschieben." : "Setze dein Licht mit einem Klick auf die Karte.");
  } catch (e){
    console.error(e);
    setStatus("Konnte Lichter nicht laden. Prüfe Supabase URL/Key und Tabelle „lights“.");
  }
}

async function loadMyLight() {
  const { data } = await sb.from('lights').select('*').eq('session', session).maybeSingle();
  return data;
}

/* Klick verändert NICHT den Zoom */
map.on('click', async function(e) {
  try{
    const existing = await loadMyLight();
    if(existing) {
      await sb.from('lights').update({lat: e.latlng.lat, lng: e.latlng.lng}).eq('session', session);
    } else {
      await sb.from('lights').insert({lat: e.latlng.lat, lng: e.latlng.lng, session});
    }
    await loadLights();
  } catch(err){
    console.error(err);
    setStatus("Speichern fehlgeschlagen. Prüfe Supabase-Rechte (RLS/Policies).");
  }
});

/* Weltansicht Button: wirklich ganze Welt */
document.getElementById("btnWorld").addEventListener("click", () => {
  map.fitBounds(WORLD_BOUNDS, WORLD_FIT_OPTS);
});

/* -------------------------
   EXPORT: unabhängige Offscreen-Map
   -> immer ganze Welt, immer derselbe Look, unabhängig vom Browser-Zoom
-------------------------- */
let exportMap = null;
let exportTiles = null;
let exportLayer = null;

function ensureExportMap(){
  if(exportMap) return;

  exportMap = L.map('exportMap', {
    zoomControl: false,
    attributionControl: false,
    preferCanvas: true,
    zoomSnap: 0.25,
    zoomDelta: 0.25,
    fadeAnimation: false
  });

  // Ganze Welt in den Export-Rahmen passend
  exportMap.fitBounds(WORLD_BOUNDS, { animate:false, padding:[40,40], maxZoom: 2 });

  exportTiles = L.tileLayer(tileUrl, {
    maxZoom: 18,
    crossOrigin: true
  }).addTo(exportMap);

  exportLayer = L.layerGroup().addTo(exportMap);
}

function waitForTilesToLoad(tileLayer){
  return new Promise(resolve => {
    // tileLayer fires 'load' when all visible tiles are loaded
    tileLayer.once('load', () => {
      // 2 frames extra, damit Canvas/Marker sicher drin sind
      requestAnimationFrame(() => requestAnimationFrame(resolve));
    });

    // Falls Cache blitzschnell: minimaler Fallback
    setTimeout(resolve, 1200);
  });
}

async function generateWorldPng(){
  setStatus("Generiere Weltkarte…");

  // 1) Immer neueste Daten holen, damit Export aktuell ist
  await loadLights();

  // 2) Offscreen-Map initialisieren / re-use
  ensureExportMap();

  // 3) Offscreen-Map: Weltansicht erzwingen
  exportMap.fitBounds(WORLD_BOUNDS, { animate:false, padding:[40,40], maxZoom: 2 });

  // 4) Marker neu setzen
  exportLayer.clearLayers();
  for (const row of allLightPoints){
    const isMine = (row.session === session);
    addGlowLight(exportLayer, [row.lat, row.lng], isMine);
  }

  // 5) Warten bis Tiles da sind
  await waitForTilesToLoad(exportTiles);

  // 6) Rendern
  return new Promise((resolve, reject) => {
    leafletImage(exportMap, function(err, canvas) {
      if (err) return reject(err);
      resolve(canvas.toDataURL("image/png"));
    });
  });
}

document.getElementById("btnCard").addEventListener("click", async () => {
  try{
    const png = await generateWorldPng();
    const a = document.createElement("a");
    a.href = png;
    a.download = "eine-menschheit-erde-nacht.png";
    a.click();
    setStatus("Fertig. PNG wurde erstellt.");
  } catch (e){
    console.error(e);
    alert("Export fehlgeschlagen.");
    setStatus("Export fehlgeschlagen.");
  }
});

// Start
loadLights();
setInterval(loadLights, 30000);
</script>
</body>
</html>
