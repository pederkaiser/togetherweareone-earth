<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Together We Are One</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Supabase -->
  <script src="https://unpkg.com/@supabase/supabase-js@2"></script>

  <!-- PNG Export -->
  <script src="https://unpkg.com/leaflet-image@0.4.0/leaflet-image.js"></script>

  <style>
    :root{
      --bg0:#0b0d12;
      --bg1:#121526;
      --card: rgba(255,255,255,0.06);
      --card2: rgba(255,255,255,0.08);
      --stroke: rgba(255,255,255,0.10);

      --ghost: rgba(255,255,255,0.22);
      --text: rgba(255,255,255,0.92);
      --warm: rgba(255,220,170,0.95);

      /* === MAP TUNING (manuell + per Slider) ===
         Start entspricht ungefähr deinem bisherigen "dunkelsten" Zustand,
         und der Slider kann noch deutlich dunkler werden. */
      --map-brightness: 0.74;     /* kleiner = dunkler */
      --map-contrast: 1.18;
      --map-saturate: 0.90;

      --shade-opacity: 0.72;      /* Vignette/Film: 0..1 */
      --ocean-tint: rgba(0,0,0,0.22); /* zusätzlicher "Night"-Film */
    }

    html,body { height:100%; }
    body{
      margin: 0;
      color: var(--text);
      background:
        radial-gradient(1200px 700px at 50% 12%, rgba(40,60,110,0.35) 0%, rgba(0,0,0,0) 55%),
        radial-gradient(900px 520px at 20% 8%, rgba(130,90,40,0.18) 0%, rgba(0,0,0,0) 55%),
        linear-gradient(180deg, var(--bg1), var(--bg0));
      font-family: ui-sans-serif, system-ui, -apple-system, "SF Pro Display", "Inter", "Segoe UI", Arial, sans-serif;
      overflow-x: hidden;
    }

    .wrap{
      min-height: 100%;
      display: grid;
      grid-template-rows: auto auto 1fr auto;
      gap: 14px;
      padding: 18px 14px 18px 14px;
      box-sizing: border-box;
      max-width: 1100px;
      margin: 0 auto;
    }

    /* --- Prompter --- */
    .teleprompter{
      padding: 18px 18px 14px 18px;
      border-radius: 20px;
      background: linear-gradient(180deg, var(--card2), var(--card));
      border: 1px solid var(--stroke);
      box-shadow: 0 16px 60px rgba(0,0,0,0.35);
      backdrop-filter: blur(10px);
    }

    .tp-text{
      text-align: center;
      font-size: clamp(18px, 2.5vw, 30px);
      line-height: 1.45;
      letter-spacing: 0.2px;
      margin: 0;
      padding: 8px 10px 10px 10px;
      min-height: 3.2em;
    }

    /* WICHTIG: Zeilenumbruch erlauben */
    .tp-word{
      color: var(--ghost);
      transition: color 160ms ease, filter 160ms ease;
      white-space: normal;      /* <-- Umbrechen erlauben */
      overflow-wrap: anywhere;
    }
    .tp-space{ white-space: pre; } /* Leerzeichen exakt */

    .tp-word.done{ color: var(--warm); filter: drop-shadow(0 0 12px rgba(255,210,140,0.18)); }
    .tp-word.active{ color: rgba(255,245,235,0.98); filter: drop-shadow(0 0 18px rgba(255,210,140,0.26)); }

    .tp-meta{ display:flex; align-items:center; justify-content:center; gap: 10px; margin-top: 8px; user-select:none; }
    .tp-btn{
      width: 42px; height: 42px; border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.85);
      cursor: pointer;
      transition: background 140ms ease, transform 140ms ease;
      font-size: 18px; font-weight: 700;
    }
    .tp-btn:hover{ background: rgba(255,255,255,0.10); transform: translateY(-1px); }
    .tp-progress{ width: min(520px, 62vw); height: 8px; border-radius: 8px; overflow:hidden; background: rgba(255,255,255,0.10); border: 1px solid rgba(255,255,255,0.08); }
    .tp-progress-bar{ height:100%; width: 0%; background: linear-gradient(90deg, rgba(255,220,170,0.65), rgba(255,255,255,0.55)); transition: width 220ms ease; }

    /* --- Map --- */
    .mapWrap{
      position: relative;
      border-radius: 20px;
      overflow: hidden;
      border: 1px solid rgba(255,255,255,0.10);
      box-shadow: 0 16px 60px rgba(0,0,0,0.35);
      background: #0a0b10;
    }
    #map{ width: 100%; height: min(62vh, 520px); }

    /* Dunkelheit über Variablen steuerbar */
    .leaflet-tile{
      filter: brightness(var(--map-brightness)) contrast(var(--map-contrast)) saturate(var(--map-saturate));
    }

    /* zusätzlicher Night-Tint (macht Ozeane/Flächen "weltraumiger") */
    .mapTint{
      pointer-events:none;
      position:absolute; inset:0;
      background: var(--ocean-tint);
      mix-blend-mode: multiply;
      opacity: 1;
    }

    .mapShade{
      pointer-events:none;
      position:absolute; inset:0;
      opacity: var(--shade-opacity);
      background:
        radial-gradient(900px 420px at 50% 10%, rgba(0,0,0,0.12), rgba(0,0,0,0.78) 65%),
        radial-gradient(700px 520px at 10% 80%, rgba(0,0,0,0.10), rgba(0,0,0,0.70) 72%),
        linear-gradient(180deg, rgba(0,0,0,0.10), rgba(0,0,0,0.60));
      mix-blend-mode: multiply;
    }

    .hud{
      position:absolute;
      left: 12px;
      top: 12px;
      display:flex;
      gap: 10px;
      z-index: 500;
      flex-wrap: wrap;
      align-items: center;
    }
    .hud button{
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.22);
      color: rgba(255,255,255,0.92);
      cursor: pointer;
      backdrop-filter: blur(10px);
      transition: background 140ms ease, transform 140ms ease;
      font-weight: 650;
      letter-spacing: 0.2px;
    }
    .hud button:hover{ background: rgba(0,0,0,0.30); transform: translateY(-1px); }

    .hud .sliderBox{
      display:flex; align-items:center; gap:8px;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.22);
      backdrop-filter: blur(10px);
      color: rgba(255,255,255,0.85);
      font-weight: 650;
    }
    .hud input[type="range"]{ width: 150px; }

    .hint{ text-align:center; margin: 4px 0 0 0; color: rgba(255,255,255,0.60); font-size: 14px; }
    .status{ text-align:center; color: rgba(255,255,255,0.70); font-size: 13px; margin-top: 6px; }

    /* Export-Look: macht die Karte im PNG noch "space night" */
    .exporting .mapShade{ opacity: 0.88 !important; }
    .exporting .mapTint{ background: rgba(0,0,0,0.30) !important; }
    .exporting .leaflet-tile{ filter: brightness(0.62) contrast(1.25) saturate(0.85) !important; }

    @media (max-width: 600px){
      .wrap{ padding: 12px 10px; }
      .teleprompter{ padding: 14px 12px 12px 12px; border-radius: 18px; }
      .tp-btn{ width: 40px; height: 40px; border-radius: 14px; }
      #map{ height: 52vh; }
      .hud input[type="range"]{ width: 120px; }
    }
  </style>
</head>

<body>
  <div class="wrap">

    <div class="teleprompter" aria-label="Text">
      <p class="tp-text" id="tp-text"></p>
      <div class="tp-meta">
        <button class="tp-btn" id="tp-prev" title="Zurück" aria-label="Zurück">←</button>
        <div class="tp-progress"><div class="tp-progress-bar" id="tp-bar"></div></div>
        <button class="tp-btn" id="tp-next" title="Weiter" aria-label="Weiter">→</button>
      </div>
    </div>

    <div class="mapWrap" id="mapWrap">
      <div class="hud">
        <button id="btnWorld" title="Alle Lichter zeigen (ohne zu nah reinzuzoomen)">Weltansicht</button>
        <button id="btnCard" title="PNG als Weltansicht erzeugen">Karte generieren</button>

        <!-- Dunkel-Regler -->
        <div class="sliderBox" title="Dunkelheit der Karte (kann jetzt deutlich dunkler werden)">
          Dunkel
          <input id="shadeSlider" type="range" min="0" max="100" value="35" />
        </div>
      </div>

      <div id="map"></div>
      <div class="mapTint" id="mapTint"></div>
      <div class="mapShade" id="mapShade"></div>
    </div>

    <p class="hint">Klicke auf die Karte, um dein Licht zu setzen oder zu verschieben. (Nur ein Licht pro Browser.)</p>
    <p class="status" id="status"></p>
  </div>

<script>
/* -------------------------
   PROMPTER: Wörter bleiben nach Highlight warm ("bauen sich auf")
-------------------------- */
const tpTexts = [
  "Manchmal schauen wir in den Himmel.",
  "Vielleicht sehen wir einen Stern, den Mond, ferne Galaxien.",
  "Für einen Moment wird uns bewusst, wie klein unser Planet ist.",
  "Wie selten – vielleicht sogar einzigartig – das Leben hier ist.",
  "Auf diesem winzigen Punkt im Weltall teilen wir unser Leben.",
  "Jeder von uns mit einer eigenen Geschichte, aber doch alle miteinander verbunden.",
  "Nicht durch Herkunft, Sprache oder Grenzen – sondern durch das Glück, gemeinsam hier zu sein.",
  "Manche Menschen spüren in solchen Momenten, dass wir eigentlich eine einzige Gemeinschaft sind.",
  "Dass uns mehr verbindet als trennt.",
  "Hast du das auch schon einmal gefühlt?",
  "Helf’ uns, dieses Gefühl sichtbar zu machen!"
];

const WORD_MS = 240;
const SENTENCE_PAUSE = 900;

let tpIndex = 0;
let tpWordIdx = 0;
let tpTimer = null;

const tpTextEl = document.getElementById("tp-text");
const tpBarEl  = document.getElementById("tp-bar");

function renderSentence(sentence){
  const tokens = sentence.split(/(\s+)/); // Worte + Leerzeichen behalten
  tpTextEl.innerHTML = tokens.map(t => {
    if (/^\s+$/.test(t)) return `<span class="tp-space">${t}</span>`;
    return `<span class="tp-word">${t}</span>`;
  }).join("");
}

function markProgress(activeWordIdx){
  const wordSpans = Array.from(tpTextEl.querySelectorAll(".tp-word"));
  wordSpans.forEach((w, i) => {
    w.classList.remove("active");
    if (i <= activeWordIdx) w.classList.add("done");
    else w.classList.remove("done");
  });
  if (wordSpans[activeWordIdx]) wordSpans[activeWordIdx].classList.add("active");
}

function updateProgress(){
  tpBarEl.style.width = `${100 * (tpIndex + 1) / tpTexts.length}%`;
}

function playSentence(idx, auto=true){
  clearInterval(tpTimer);
  tpIndex = idx;
  tpWordIdx = 0;
  renderSentence(tpTexts[tpIndex]);
  updateProgress();

  const words = tpTexts[tpIndex].split(/\s+/).filter(Boolean);
  markProgress(0);

  tpTimer = setInterval(() => {
    tpWordIdx++;
    if (tpWordIdx < words.length){
      markProgress(tpWordIdx);
    } else {
      clearInterval(tpTimer);
      markProgress(words.length - 1);
      if(auto){
        setTimeout(() => {
          if(tpIndex < tpTexts.length - 1) playSentence(tpIndex + 1, true);
        }, SENTENCE_PAUSE);
      }
    }
  }, WORD_MS);
}

document.getElementById("tp-next").onclick = () => {
  if(tpIndex < tpTexts.length - 1) playSentence(tpIndex + 1, false);
};
document.getElementById("tp-prev").onclick = () => {
  if(tpIndex > 0) playSentence(tpIndex - 1, false);
};
playSentence(0, true);

/* -------------------------
   MAP "von Hand" dunkler machen: Slider steuert CSS Vars
   Wunsch: "es soll beim jetzigen dunkelsten anfangen und noch dunkler werden"
   -> Slider 0 startet bei "alt dunkel", Slider 100 wird deutlich dunkler.
-------------------------- */
const shadeSlider = document.getElementById("shadeSlider");

// Startwerte entsprechen etwa deinem bisherigen Maximum (alt):
//   shadeOpacity ~0.85, brightness ~0.74
// Jetzt erweitern wir nach unten bis ~0.48 brightness & ~0.97 shade
function applyDarkness(v){
  const t = v / 100;

  // Dunkel-Film: 0.72 .. 0.97
  const shadeOpacity = 0.72 + t * 0.25;

  // Tiles: 0.74 .. 0.48 (deutlich dunkler möglich)
  const brightness = 0.74 - t * 0.26;

  // Ozean-Tint: 0.22 .. 0.38
  const ocean = 0.22 + t * 0.16;

  document.documentElement.style.setProperty("--shade-opacity", shadeOpacity.toFixed(2));
  document.documentElement.style.setProperty("--map-brightness", brightness.toFixed(2));
  document.documentElement.style.setProperty("--ocean-tint", `rgba(0,0,0,${ocean.toFixed(2)})`);
}

// Slider-Default 35 = schon dunkel, aber nicht maximal
applyDarkness(parseInt(shadeSlider.value, 10));
shadeSlider.addEventListener("input", (e) => applyDarkness(parseInt(e.target.value, 10)));

/* -------------------------
   MAP + SUPABASE
-------------------------- */
function uuidv4() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    var r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

const SUPABASE_URL = 'https://gwfqdukbcgtcefqtgnbl.supabase.co';  // <-- DEIN Project URL
const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imd3ZnFkdWtiY2d0Y2VmcXRnbmJsIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njg3MDU2MTMsImV4cCI6MjA4NDI4MTYxM30.ePyuDxhVoc1ol5lQ8JbRKaybgpEPozBR3Wf71oFj040';  // <-- DEIN anon public key

const statusEl = document.getElementById("status");
function setStatus(msg){ statusEl.textContent = msg || ""; }

const sb = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

let session = localStorage.getItem('myLightSession');
if(!session) { session = uuidv4(); localStorage.setItem('myLightSession', session); }

const map = L.map('map', {
  zoomControl: true,
  worldCopyJump: true,
  preferCanvas: true
}).setView([20, 0], 2);

// Basemap: Voyager (Kontinente sichtbar), Space-Look entsteht per Tint/Shader/Export-Mode
L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
  attribution: '&copy; OpenStreetMap &copy; CARTO',
  maxZoom: 18,
}).addTo(map);

// Lichter: Glow + Kern; für "Straßenlaternen aus dem All" verstärken wir Glow leicht
const canvasRenderer = L.canvas({ padding: 0.5 });
const lightsLayer = L.layerGroup().addTo(map);

function addGlowLight(latlng, isMine=false){
  // Glow außen
  L.circleMarker(latlng, {
    renderer: canvasRenderer,
    radius: isMine ? 14 : 12,
    stroke: false,
    fill: true,
    fillOpacity: 0.16,
    fillColor: "rgba(255,215,160,1)",
    interactive: false
  }).addTo(lightsLayer);

  // Glow innen
  L.circleMarker(latlng, {
    renderer: canvasRenderer,
    radius: isMine ? 8 : 7,
    stroke: false,
    fill: true,
    fillOpacity: 0.18,
    fillColor: "rgba(255,230,190,1)",
    interactive: false
  }).addTo(lightsLayer);

  // Kernpunkt
  L.circleMarker(latlng, {
    renderer: canvasRenderer,
    radius: isMine ? 3.8 : 3.0,
    stroke: false,
    fill: true,
    fillOpacity: 0.96,
    fillColor: "rgba(255,250,245,1)",
    interactive: isMine
  }).addTo(lightsLayer);
}

let allLightPoints = [];

async function loadLights() {
  try{
    setStatus("Lichter laden…");
    const { data, error } = await sb.from('lights').select('*');
    if(error) throw error;

    allLightPoints = data || [];
    lightsLayer.clearLayers();

    let mine = null;
    for (const row of allLightPoints){
      const isMine = (row.session === session);
      if(isMine) mine = row;
      addGlowLight([row.lat, row.lng], isMine);
    }

    setStatus(mine ? "Dein Licht ist gesetzt. Du kannst es durch Klicken verschieben." : "Setze dein Licht mit einem Klick auf die Karte.");
  } catch (e){
    console.error(e);
    setStatus("Konnte Lichter nicht laden. Prüfe Supabase URL/Key und Tabelle „lights“.");
  }
}

async function loadMyLight() {
  const { data } = await sb.from('lights').select('*').eq('session', session).maybeSingle();
  return data;
}

// Klick verändert NICHT den Zoom
map.on('click', async function(e) {
  try{
    const existing = await loadMyLight();
    if(existing) {
      await sb.from('lights').update({lat: e.latlng.lat, lng: e.latlng.lng}).eq('session', session);
    } else {
      await sb.from('lights').insert({lat: e.latlng.lat, lng: e.latlng.lng, session});
    }
    await loadLights();
  } catch(err){
    console.error(err);
    setStatus("Speichern fehlgeschlagen. Prüfe Supabase-Rechte (RLS/Policies).");
  }
});

/* -------------------------
   WELTANSICHT & EXPORT (Fix)
   Problem vorher: fitBounds zoomt bei wenigen Lichtern stark rein.
   Lösung:
   - Weltansicht-Button: zeigt alle Lichter, aber NIE näher als maxZoom.
   - Export: IMMER feste Weltansicht (kein fitBounds), wartet auf moveend/idle, dann rendert.
-------------------------- */
const WORLD_VIEW = { center: [20, 0], zoom: 2 };
const MAX_ZOOM_WORLD_FIT = 2.2;

function showWorldView(){
  map.setView(WORLD_VIEW.center, WORLD_VIEW.zoom, { animate: true });
}

function fitToLightsWorldish(){
  if(!allLightPoints || allLightPoints.length === 0){
    showWorldView();
    return;
  }
  const bounds = L.latLngBounds(allLightPoints.map(p => [p.lat, p.lng]));
  map.fitBounds(bounds.pad(0.35), {
    animate: true,
    duration: 0.9,
    maxZoom: MAX_ZOOM_WORLD_FIT
  });
}

document.getElementById("btnWorld").addEventListener("click", () => fitToLightsWorldish());

function waitForNextFrame(){
  return new Promise(r => requestAnimationFrame(() => r()));
}
function waitForMapSettled(){
  return new Promise(resolve => {
    // moveend fired after setView/fitBounds finishes
    map.once("moveend", () => {
      // one extra frame so tiles/canvas settle
      requestAnimationFrame(() => requestAnimationFrame(resolve));
    });
  });
}

document.getElementById("btnCard").addEventListener("click", async () => {
  const mapWrap = document.getElementById("mapWrap");

  // 1) Export-Look aktivieren (mehr "Earth at night")
  mapWrap.classList.add("exporting");

  // 2) Fixe Weltansicht setzen (niemals fitBounds!)
  showWorldView();

  // 3) Warten bis die Weltansicht wirklich steht
  await waitForMapSettled();

  // 4) Export rendern
  leafletImage(map, function(err, canvas) {
    // Export-Look wieder zurück
    mapWrap.classList.remove("exporting");

    if (err) { alert("Export fehlgeschlagen."); return; }
    const png = canvas.toDataURL("image/png");
    const a = document.createElement("a");
    a.href = png;
    a.download = "eine-menschheit-erde-nacht.png";
    a.click();
  });
});

// Start
loadLights();
setInterval(loadLights, 30000);
</script>
</body>
</html>
